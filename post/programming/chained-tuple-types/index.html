<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Chained Tuple Types - Code, lol.</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Chained Tuple Types" />
<meta property="og:description" content="With Typescript 4.1, it&rsquo;s now possible to use variadic tuple types to construct large types with what appears to be runtime code. The general idea is that we will utilize a chaining pattern, where each operation on the chain returns an expanded version of the chain&rsquo;s type.
To motivate the example, let us consider a Set class. Our Set is a chaining class, where you may insert, remove, and check for the existence of numbers." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/programming/chained-tuple-types/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-01-05T20:23:23-08:00" />
<meta property="article:modified_time" content="2021-01-05T20:23:23-08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="Code, lol." rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">Code, lol.</div>
					<div class="logo__tagline">Mike&#39;s code blog. Come ye all and rejoice!</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About Me</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/contact/">
				
				<span class="menu__text">Contact</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/papers/">
				
				<span class="menu__text">Papers</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Chained Tuple Types</h1>
			
		</header><div class="content post__content clearfix">
			<p>With Typescript 4.1, it&rsquo;s now possible to use variadic tuple types to construct large types with what appears to be runtime code. The general idea is that we will utilize a chaining pattern, where each operation on the chain returns an expanded version of the chain&rsquo;s type.</p>
<p>To motivate the example, let us consider a <code>Set</code> class. Our <code>Set</code> is a chaining class, where you may insert, remove, and check for the existence of numbers. To end the chain, you call <code>.value()</code> which returns an array of numbers.</p>
<p>Here is an example of how you might use <code>Set</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#080;font-weight:bold">const</span> <span style="color:#080;font-weight:bold">set</span> <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">new</span> Set()
  .insert(<span style="color:#00d;font-weight:bold">2</span>)
  .insert(<span style="color:#00d;font-weight:bold">4</span>)
  .insert(<span style="color:#00d;font-weight:bold">8</span>)

<span style="color:#080;font-weight:bold">const</span> hasTwo <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">set</span>.has(<span style="color:#00d;font-weight:bold">2</span>) <span style="color:#888">// true
</span><span style="color:#888"></span>
<span style="color:#080;font-weight:bold">const</span> value <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">set</span>.remove(<span style="color:#00d;font-weight:bold">2</span>).value() <span style="color:#888">// [4, 8]
</span></code></pre></div><blockquote>
<p><a href="https://www.typescriptlang.org/play?#code/PQKgBApgzgNglgOwC4FoAmcoEMBGMKSyKoDGA9gLYUTJTAbZ4Qo274oAOWcATmCMABQoMAHUCaMggDkSMFhJIArlhgwAnpAAeSGmjBIAFgQDmMMjlVgAyhDkWAVhEUAaMFDJgAZqqjMOZFBwSHAAbhAAXPxCItDwyOiYbAQIZChKfiw6eigIWCHhwKnpmRDZCGi5+WEEAoLCICCC-GAAYnAwunxkSnIQ4TyaEPjUyGAU+SSGiCZgAHJgiAbGBkoc+GAAKgB0zXVI6hwE7Z0QPAA8m9q6FVBgSggA1qkA7ggA2gC6bnMAfGAAXi21z0dy+zTAAH4wOCwGAolcyjc0GDEF4zmAABJuba4tEYgBKnwh0MxINu8whcOhJy65wJP1+VPhMOxYFx21pZ3pjOJcIRAG56qAmi0ACJ2M4URAEF7GIwYrAIIYjGhIO4TJBTGbzbSYORLBWrdYEHZgACSXjALwIXkQaD2YCkEDcPDsSh4CEgWB4Gm2YAAFFBDGQeKReCQlMEAJR7IQHI5gACiWn1UEu5JR9yerw+33m-yBiPKWdhUO8vggEIRmdRCHRfDZHPxfCJJKxtcpcOpBh4Sir3ZZKbTPIL1bAODIZHwSqFDVF4E2K2IZzyMAMhwIWCgHhIcHyEH0L2ChnkXsQUCQSpIBDIVqwNjsu2igjKATDG8TtiQ5oQl+vEDnEmqq0J2CBKBQOBnF8gIwp8hZgAA3hCF5nEg5zWEce52iQABqqj9mBEFQTwvwBsyWhRJhzhwDh+EwP2ELRlRdi-v+CA3uc7wclyFzARAozqm41HYXAeEERAvzCVhtFifR-bwXOcJuhQZDhBhMl0RJRGQWcZEUVRmlyRJTEsT+f5XhxgG8UBIFCTYRniQxkm-EpYCGNuGk0Vpzk6SR+mDpRDnecZzmmcmqaXum-GCVA0khU5-aufUcKhBJAbMcmdlQEKAC+c4io6S4EN+YDkBZfaKKGn4QP64jWjwWAcMsBAXpZN41YsXqhmgGJIJ4HBuuEyCOqEmBwDgHTBJod7jHYIb6F4DyKHAUg1XcUFeKGBDlZelUhGtHl3GQJCRjwbpoM+dRvqGcgJiVdiwchcIIBALyBpl35se1EB5QVjRFSspV9sgcDUGVMDbncYMmoJ1RSG4vWhGQcD6LN0wmMYPAoPg4Trvd0PdTwvU8I6-XjFgjwEEaIMhOD5C9fIdwkDOfDbmAAQ7hNGzk26WCXXGgi7XIpVAgGLNQ0hEKDWEB7uHYUTgbpPAwUCXxuRwSh4GJXV+GGAZBUrJHRlLg5GJg2x+HIascubUCW0+dqnDwAYBuoJsAv8mgAIQAkCWjRm4WifEKg5usonrLJgodgLlKUc1r8AkGAKlqRABuK8RZwm893Z2w71tR-bVvbE7XSu+7gJe2Avv+9GMfKe6kd2zHcfS4nOtHRnYBG9npt59MxdPogLNKL1UAG-XzLhx6XotxCbdwpr2vJ2lzkZf3jcR163G4vnVshwvgi5Uz2bPGQbwm+z37-QuYAoA-j9P8-L+v2-78f5-b+OnCKZYBQJo7jADAGKHgNQ+AAGEyC9UdF-OB8CEGIKfnUecjo-4AI2AARgRGsDYbE0KrQQILe6EVMEAH0ADyYCTCICsGrAATG4AALG4AAHIfEhKZyFzDejFNUsFMEAAYhQ3Q-JwrQ5CCTQCUJ0JUSAACC50sCaBtriLhlDqG0JgG4dRPCXh8OQIfVBLR0EmjAPQhEm4cb9GGI+OQ+CwyEMFqIuQwsIr0Ngq9d634MrbFQvreh0Y-F-jQgGJhQS179gyrfNBWh-5mIAMw4LMVI1Sa9iGbgigkjRcAaFrlgu8RhYAWFgHYSIrQ747qZJTNkqRUAZGWQUUolRbQOh0hqTkvJqg3D0OSsY8ApiNhMMsUcaxeM7FgFSWpVQziKm3TKlIS8EUmGeLenY3x-ikABkCcEvWWzwnbFTuEbZET0pT36RFeJGwACsIzmC41sQYuQw5Lw0A6hA4wJBHhQAyYmFM1yyGYIKUUkpZTXxzLEdUrQALyGYm3K0HofAgQvPVEBaFgLmGuTAMAYBSA+xVnBZUzq-yyEeKBL3FWh8XHEvRfQshcKoAIo9LBFF0V0WYMxQKbFwDJzTggEqYUAMTFxIwQQAAbHcsZtjSooreQQD5zhHgzEFm4klQLyVrJ8UEzZJzdmhIOTq1hQSu7hK5Ti3sjFqWqtpas7xdgNkhICUEo56cdld0CWa4BPgYB+EEEAA">Note: all of this code is on <strong>TS Playground</strong> :)</a></p>
</blockquote>
<p>It would be interesting to have a version of <code>Set</code> which can infer that the final <code>value</code> type is the tuple type <code>[4, 8]</code>. This is what we will attempt to do.</p>
<h2 id="baldis-basics">Baldi&rsquo;s Basics</h2>
<p>Let&rsquo;s begin with a specification of the <code>Set</code> type which obeys our chaining constraints, such that the <code>insert</code> and <code>remove</code> method returns an instance of <code>Set</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#080;font-weight:bold">export</span> <span style="color:#080;font-weight:bold">type</span> Set <span style="color:#333">=</span> {
  <span style="color:#080;font-weight:bold">new</span> ()<span style="color:#333">:</span> Set;
  insert(x: <span style="color:#339;font-weight:bold">number</span>)<span style="color:#333">:</span> Set;
  remove(x: <span style="color:#339;font-weight:bold">number</span>)<span style="color:#333">:</span> Set;
  has(x: <span style="color:#339;font-weight:bold">number</span>)<span style="color:#333">:</span> <span style="color:#080;font-weight:bold">boolean</span>;
  value()<span style="color:#333">:</span> <span style="color:#339;font-weight:bold">number</span>[]
};
</code></pre></div><p>The <code>new (): T</code> syntax specifies a constructor, and allows the <code>new</code> keyword to be used, which in this case is an ergonomic choice.</p>
<p>The next improvement we will make is to add a tuple type parameter to <code>Set</code>, which extends an array of numbers. We will additionally make the default value of that type parameter the empty array. This type parameter represents the current contents of <code>Set</code>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#080;font-weight:bold">export</span> <span style="color:#080;font-weight:bold">type</span> Set&lt;<span style="color:#070">Elements</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span><span style="color:#f00;background-color:#faa">[]</span> <span style="color:#f00;background-color:#faa">=</span> <span style="color:#f00;background-color:#faa">[]</span>&gt; <span style="color:#333">=</span> {
  <span style="color:#080;font-weight:bold">new</span> ()<span style="color:#333">:</span> Set&lt;<span style="color:#070">Elements</span>&gt;;
  insert(x: <span style="color:#339;font-weight:bold">number</span>)<span style="color:#333">:</span> Set&lt;<span style="color:#070">Elements</span>&gt;;
  remove(x: <span style="color:#339;font-weight:bold">number</span>)<span style="color:#333">:</span> Set&lt;<span style="color:#070">Elements</span>&gt;;
  has(x: <span style="color:#339;font-weight:bold">number</span>)<span style="color:#333">:</span> <span style="color:#080;font-weight:bold">boolean</span>;
  value()<span style="color:#333">:</span> Elements
};
</code></pre></div><p>In preparation, let us next specify that each member function which takes in a number, additionally takes in an inferred type based on the value which it is passed. Each of these types represent the specific value which was passed in.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#080;font-weight:bold">export</span> <span style="color:#080;font-weight:bold">type</span> Set&lt;<span style="color:#070">Elements</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span><span style="color:#f00;background-color:#faa">[]</span> <span style="color:#f00;background-color:#faa">=</span> <span style="color:#f00;background-color:#faa">[]</span>&gt; <span style="color:#333">=</span> {
  <span style="color:#080;font-weight:bold">new</span> ()<span style="color:#333">:</span> Set&lt;<span style="color:#070">Elements</span>&gt;;
  insert&lt;<span style="color:#070">SpecificValue</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span>&gt;(x: <span style="color:#339;font-weight:bold">SpecificValue</span>)<span style="color:#333">:</span> Set&lt;<span style="color:#070">Elements</span>&gt;;
  remove&lt;<span style="color:#070">SpecificValue</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span>&gt;(x: <span style="color:#339;font-weight:bold">SpecificValue</span>)<span style="color:#333">:</span> Set&lt;<span style="color:#070">Elements</span>&gt;;
  has&lt;<span style="color:#070">SpecificValue</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span>&gt;(x: <span style="color:#339;font-weight:bold">SpecificValue</span>)<span style="color:#333">:</span> <span style="color:#080;font-weight:bold">boolean</span>;
  value()<span style="color:#333">:</span> Elements;
};
</code></pre></div><h2 id="tuple-insertion">Tuple Insertion</h2>
<p>In the following example, we can see how to represent the addition of a new element into an existing tuple type. This uses a recently developed tuple destructuring syntax. We could also prepend elements by switching the positions of <code>Ex1_Original</code> and <code>Ex1_NewElement</code> on the last line.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#080;font-weight:bold">type</span> Ex1_Original <span style="color:#333">=</span> [<span style="color:#00d;font-weight:bold">2</span>, <span style="color:#00d;font-weight:bold">4</span>, <span style="color:#00d;font-weight:bold">8</span>];
<span style="color:#080;font-weight:bold">type</span> Ex1_NewElement <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">10</span>;
<span style="color:#080;font-weight:bold">type</span> Ex1_ResultantArray <span style="color:#333">=</span> [...Ex1_Original, Ex1_NewElement]; <span style="color:#888">// [2, 4, 8, 10]
</span></code></pre></div><p>We can use the above simple example to finish our <code>insert</code> method type, by specifying that <code>insert</code> returns an instance of <code>Set</code> with the type of our specific value appended to the current tuple type. We will additionally introduce some whitespace to reduce visual noise.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#080;font-weight:bold">export</span> <span style="color:#080;font-weight:bold">type</span> Set&lt;<span style="color:#070">Elements</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span><span style="color:#f00;background-color:#faa">[]</span> <span style="color:#f00;background-color:#faa">=</span> <span style="color:#f00;background-color:#faa">[]</span>&gt; <span style="color:#333">=</span> {
  <span style="color:#080;font-weight:bold">new</span> ()<span style="color:#333">:</span> Set&lt;<span style="color:#070">Elements</span>&gt;;

  insert&lt;<span style="color:#070">SpecificValue</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span>&gt;(
    x: <span style="color:#339;font-weight:bold">SpecificValue</span>
  )<span style="color:#333">:</span> Set<span style="color:#333">&lt;</span>[...Elements, SpecificValue]<span style="color:#333">&gt;</span>;

  remove&lt;<span style="color:#070">SpecificValue</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span>&gt;(x: <span style="color:#339;font-weight:bold">SpecificValue</span>)<span style="color:#333">:</span> Set&lt;<span style="color:#070">Elements</span>&gt;;

  has&lt;<span style="color:#070">SpecificValue</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span>&gt;(x: <span style="color:#339;font-weight:bold">SpecificValue</span>)<span style="color:#333">:</span> <span style="color:#080;font-weight:bold">boolean</span>;

  value()<span style="color:#333">:</span> Elements;
};
</code></pre></div><p>At this point, we may use the <code>insert</code> and <code>value()</code> methods and expect they will infer the transient types automatically. This general approach for continually building up types in a &ldquo;runtime-fashion&rdquo; is very useful for writing easy-to-use and type-safe libraries.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#080;font-weight:bold">const</span> Ex2_Array <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">new</span> Set().insert(<span style="color:#00d;font-weight:bold">2</span>).insert(<span style="color:#00d;font-weight:bold">4</span>).value(); <span style="color:#888">// [2, 4]
</span></code></pre></div><h2 id="tuple-removal">Tuple Removal</h2>
<p>As of yet, there is no built-in operation for tuple removal. However, it can be implemented using a recursive loop on the type level, the mechanics of which would detract from this article. Of note - at the time of writing, <code>ts-toolbelt</code> uses a less modern variant than the following, and will not work. I may attempt to explain tuple type loops in another article.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#080;font-weight:bold">type</span> Filter&lt;<span style="color:#070">T</span> <span style="color:#00c">extends</span> <span style="color:#00c">unknown</span><span style="color:#f00;background-color:#faa">[],</span> <span style="color:#00c">N</span>&gt; <span style="color:#333">=</span> T <span style="color:#080;font-weight:bold">extends</span> []
  <span style="color:#333">?</span> []
  <span style="color:#333">:</span> T <span style="color:#080;font-weight:bold">extends</span> [<span style="color:#080;font-weight:bold">infer</span> H, ...<span style="color:#080;font-weight:bold">infer</span> R]
  <span style="color:#333">?</span> H <span style="color:#080;font-weight:bold">extends</span> N
    <span style="color:#333">?</span> Filter&lt;<span style="color:#070">R</span><span style="color:#f00;background-color:#faa">,</span> <span style="color:#00c">N</span>&gt;
    <span style="color:#333">:</span> [H, ...Filter&lt;<span style="color:#070">R</span><span style="color:#f00;background-color:#faa">,</span> <span style="color:#00c">N</span>&gt;]
  <span style="color:#333">:</span> T;

<span style="color:#080;font-weight:bold">type</span> Ex3_Original <span style="color:#333">=</span> [<span style="color:#00d;font-weight:bold">2</span>, <span style="color:#00d;font-weight:bold">4</span>, <span style="color:#00d;font-weight:bold">8</span>];
<span style="color:#080;font-weight:bold">type</span> Ex3_ResultantArray <span style="color:#333">=</span> Filter&lt;<span style="color:#070">Ex3_Original</span><span style="color:#f00;background-color:#faa">,</span> <span style="color:#00c">2</span>&gt;; <span style="color:#888">// [4, 8]
</span></code></pre></div><p>We can deputize this ability to empower our <code>remove</code> method to remove the corresponding element types from our tuple type.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#080;font-weight:bold">export</span> <span style="color:#080;font-weight:bold">type</span> Set&lt;<span style="color:#070">Elements</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span><span style="color:#f00;background-color:#faa">[]</span> <span style="color:#f00;background-color:#faa">=</span> <span style="color:#f00;background-color:#faa">[]</span>&gt; <span style="color:#333">=</span> {
  <span style="color:#080;font-weight:bold">new</span> ()<span style="color:#333">:</span> Set&lt;<span style="color:#070">Elements</span>&gt;;

  insert&lt;<span style="color:#070">SpecificValue</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span>&gt;(
    x: <span style="color:#339;font-weight:bold">SpecificValue</span>
  )<span style="color:#333">:</span> Set<span style="color:#333">&lt;</span>[...Elements, SpecificValue]<span style="color:#333">&gt;</span>;

  remove&lt;<span style="color:#070">SpecificValue</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span>&gt;(
    x: <span style="color:#339;font-weight:bold">SpecificValue</span>
  )<span style="color:#333">:</span> Set&lt;<span style="color:#070">Filter</span><span style="color:#f00;background-color:#faa">&lt;</span><span style="color:#00c">Elements</span><span style="color:#f00;background-color:#faa">,</span> <span style="color:#00c">SpecificValue</span>&gt;<span style="color:#333">&gt;</span>;

  has&lt;<span style="color:#070">SpecificValue</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span>&gt;(x: <span style="color:#339;font-weight:bold">SpecificValue</span>)<span style="color:#333">:</span> <span style="color:#080;font-weight:bold">boolean</span>;

  value()<span style="color:#333">:</span> Elements;
};
</code></pre></div><p>At this point, we are able to insert, remove, and get the array value of the numbers we place into our <code>Set</code> object:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#080;font-weight:bold">const</span> Ex4 <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">new</span> Set().insert(<span style="color:#00d;font-weight:bold">2</span>).insert(<span style="color:#00d;font-weight:bold">4</span>).remove(<span style="color:#00d;font-weight:bold">2</span>).value(); <span style="color:#888">// [4]
</span></code></pre></div><h2 id="tuple-insertion-2---duplicate-edge-case">Tuple Insertion #2 - Duplicate Edge Case</h2>
<p>Readers following along very closely may have noticed an issue with our <code>insert</code> method type - namely, that multiple insertions of the same value will emplace duplicates on the type level. Since <code>Set</code> is a set, this is not wanted.</p>
<p>Luckily, with our <code>Filter</code> utility type available, we can ensure no duplicates exist by first filtering out that value type.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#080;font-weight:bold">export</span> <span style="color:#080;font-weight:bold">type</span> Set&lt;<span style="color:#070">Elements</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span><span style="color:#f00;background-color:#faa">[]</span> <span style="color:#f00;background-color:#faa">=</span> <span style="color:#f00;background-color:#faa">[]</span>&gt; <span style="color:#333">=</span> {
  <span style="color:#080;font-weight:bold">new</span> ()<span style="color:#333">:</span> Set&lt;<span style="color:#070">Elements</span>&gt;;

  insert&lt;<span style="color:#070">SpecificValue</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span>&gt;(
    x: <span style="color:#339;font-weight:bold">SpecificValue</span>
  )<span style="color:#333">:</span> Set<span style="color:#333">&lt;</span>[...Filter&lt;<span style="color:#070">Elements</span><span style="color:#f00;background-color:#faa">,</span> <span style="color:#00c">SpecificValue</span>&gt;, SpecificValue]<span style="color:#333">&gt;</span>;

  remove&lt;<span style="color:#070">SpecificValue</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span>&gt;(
    x: <span style="color:#339;font-weight:bold">SpecificValue</span>
  )<span style="color:#333">:</span> Set&lt;<span style="color:#070">Filter</span><span style="color:#f00;background-color:#faa">&lt;</span><span style="color:#00c">Elements</span><span style="color:#f00;background-color:#faa">,</span> <span style="color:#00c">SpecificValue</span>&gt;<span style="color:#333">&gt;</span>;

  has&lt;<span style="color:#070">SpecificValue</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span>&gt;(x: <span style="color:#339;font-weight:bold">SpecificValue</span>)<span style="color:#333">:</span> <span style="color:#080;font-weight:bold">boolean</span>;

  value()<span style="color:#333">:</span> Elements;
};
</code></pre></div><p>Note that we could have just as well determined whether or not the value was already present, and decided whether or not to insert it. This underlines the isomorphism between the value-level and the type-level - specifically that in a lot of cases, any given operation you could think of has both a value-level component and a type-level component, including array operations, arithmetic, graph operations, etc.</p>
<p>As well, any given type specification will have multiple possible representations, with differing efficiency, albeit with respect to compilation time and memory in lieu of runtime cost.</p>
<h2 id="tuple-existence-checks">Tuple Existence Checks</h2>
<p>For existence check, we can utilize <code>extends</code> - we convert the tuple to a union and perform an extends check to determine whether or not the given element is present in the tuple.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#080;font-weight:bold">type</span> Has&lt;<span style="color:#070">T</span> <span style="color:#00c">extends</span> <span style="color:#00c">unknown</span><span style="color:#f00;background-color:#faa">[],</span> <span style="color:#00c">X</span>&gt; <span style="color:#333">=</span> X <span style="color:#080;font-weight:bold">extends</span> T[<span style="color:#339;font-weight:bold">number</span>] <span style="color:#333">?</span> <span style="color:#080;font-weight:bold">true</span> <span style="color:#333">:</span> <span style="color:#080;font-weight:bold">false</span>;

<span style="color:#080;font-weight:bold">type</span> Ex5_1 <span style="color:#333">=</span> [<span style="color:#00d;font-weight:bold">2</span>, <span style="color:#00d;font-weight:bold">4</span>, <span style="color:#00d;font-weight:bold">8</span>];
<span style="color:#080;font-weight:bold">type</span> Ex5_1_HasFour <span style="color:#333">=</span> Has&lt;<span style="color:#070">Ex5_1</span><span style="color:#f00;background-color:#faa">,</span> <span style="color:#00c">4</span>&gt;; <span style="color:#888">// true
</span><span style="color:#888"></span>
<span style="color:#080;font-weight:bold">type</span> Ex5_2 <span style="color:#333">=</span> <span style="color:#339;font-weight:bold">number</span>[];
<span style="color:#080;font-weight:bold">type</span> Ex5_2_HasFour <span style="color:#333">=</span> Has&lt;<span style="color:#070">Ex5_1</span><span style="color:#f00;background-color:#faa">,</span> <span style="color:#00c">4</span>&gt;; <span style="color:#888">// boolean
</span></code></pre></div><p>We now have enough code to finish our type specification of <code>Set</code>, complete with a type-safe existence check.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#080;font-weight:bold">export</span> <span style="color:#080;font-weight:bold">type</span> Set&lt;<span style="color:#070">Elements</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span><span style="color:#f00;background-color:#faa">[]</span> <span style="color:#f00;background-color:#faa">=</span> <span style="color:#f00;background-color:#faa">[]</span>&gt; <span style="color:#333">=</span> {
  <span style="color:#080;font-weight:bold">new</span> ()<span style="color:#333">:</span> Set&lt;<span style="color:#070">Elements</span>&gt;;

  insert&lt;<span style="color:#070">SpecificValue</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span>&gt;(
    x: <span style="color:#339;font-weight:bold">SpecificValue</span>
  )<span style="color:#333">:</span> Set<span style="color:#333">&lt;</span>[...Filter&lt;<span style="color:#070">Elements</span><span style="color:#f00;background-color:#faa">,</span> <span style="color:#00c">SpecificValue</span>&gt;, SpecificValue]<span style="color:#333">&gt;</span>;

  remove&lt;<span style="color:#070">SpecificValue</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span>&gt;(
    x: <span style="color:#339;font-weight:bold">SpecificValue</span>
  )<span style="color:#333">:</span> Set&lt;<span style="color:#070">Filter</span><span style="color:#f00;background-color:#faa">&lt;</span><span style="color:#00c">Elements</span><span style="color:#f00;background-color:#faa">,</span> <span style="color:#00c">SpecificValue</span>&gt;<span style="color:#333">&gt;</span>;

  has&lt;<span style="color:#070">SpecificValue</span> <span style="color:#00c">extends</span> <span style="color:#00c">number</span>&gt;(
    x: <span style="color:#339;font-weight:bold">SpecificValue</span>
  )<span style="color:#333">:</span> Has&lt;<span style="color:#070">Elements</span><span style="color:#f00;background-color:#faa">,</span> <span style="color:#00c">SpecificValue</span>&gt;;

  value()<span style="color:#333">:</span> Elements;
};
</code></pre></div><p>And we can finish the section with a few examples of existence checking. Even if we insert an element, remove it, and then check, we still get the correct result. In general, this will work until the compiler no longer has patience, which is an internal implementation detail. In that case, the compiler will claim that our <code>Set</code> contains <code>number[]</code>. Though for reasonable examples, our <code>Set</code> type checking works as we expect:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#080;font-weight:bold">const</span> Ex5_1 <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">new</span> Set().insert(<span style="color:#00d;font-weight:bold">2</span>).insert(<span style="color:#00d;font-weight:bold">4</span>).insert(<span style="color:#00d;font-weight:bold">8</span>).has(<span style="color:#00d;font-weight:bold">4</span>); <span style="color:#888">// true
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">const</span> Ex5_2 <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">new</span> Set().insert(<span style="color:#00d;font-weight:bold">2</span>).remove(<span style="color:#00d;font-weight:bold">2</span>).has(<span style="color:#00d;font-weight:bold">2</span>); <span style="color:#888">// false
</span></code></pre></div><h2 id="value-level">Value-Level</h2>
<p>A value-level implementation of <code>Set</code> is provided below, mostly to demonstrate the separation between value-level implementation and type-level specification, which is sometimes wise with more involved types.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#080;font-weight:bold">const</span> Set <span style="color:#333">=</span> (<span style="color:#080;font-weight:bold">class</span> {
  <span style="color:#080;font-weight:bold">private</span> <span style="color:#080;font-weight:bold">set</span><span style="color:#333">:</span> <span style="color:#339;font-weight:bold">number</span>[] <span style="color:#333">=</span> [];

  <span style="color:#080;font-weight:bold">public</span> insert(x: <span style="color:#339;font-weight:bold">number</span>) {
    <span style="color:#080;font-weight:bold">this</span>.<span style="color:#080;font-weight:bold">set</span> <span style="color:#333">=</span> [...<span style="color:#080;font-weight:bold">this</span>.<span style="color:#080;font-weight:bold">set</span>.filter((y) <span style="color:#333">=&gt;</span> y <span style="color:#333">!==</span> x), x];
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">this</span>;
  }

  <span style="color:#080;font-weight:bold">public</span> remove(x: <span style="color:#339;font-weight:bold">number</span>) {
    <span style="color:#080;font-weight:bold">this</span>.<span style="color:#080;font-weight:bold">set</span> <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">this</span>.<span style="color:#080;font-weight:bold">set</span>.filter((y) <span style="color:#333">=&gt;</span> y <span style="color:#333">!==</span> x);
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">this</span>;
  }

  <span style="color:#080;font-weight:bold">public</span> has(x: <span style="color:#339;font-weight:bold">number</span>) {
    <span style="color:#080;font-weight:bold">this</span>.<span style="color:#080;font-weight:bold">set</span>.includes(x);
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">this</span>;
  }

  <span style="color:#080;font-weight:bold">public</span> value() {
    <span style="color:#080;font-weight:bold">return</span> [...<span style="color:#080;font-weight:bold">this</span>.<span style="color:#080;font-weight:bold">set</span>];
  }
} <span style="color:#080;font-weight:bold">as</span> <span style="color:#339;font-weight:bold">unknown</span>) <span style="color:#080;font-weight:bold">as</span> Set;
</code></pre></div><p>The downside is that we now are not doing any compile-checks against the implementation of <code>Set</code> - namely, we are not checking that <code>Set</code> actually does what the types says it will do. The issue with attempting that is that while that approach is possible, it would require every sub-function e.g. <code>includes</code>, etc. to also be just as type-safe. Essentially, for libraries in Typescript it&rsquo;s my opinion that it&rsquo;s safer and more readable to keep the type specification and the value-level separate. Application-side code should endeavor to do the opposite however.</p>
<p>It may be possible to automatically extract a simplified type of <code>Set</code> which we can validate our runtime implementation against, but it would be hard.</p>
<p>Final note: For pedagogic reasons, I have glossed over some nuance with respect to <code>new ()</code> - really, a wrapper type is needed to hide the member functions until the class is actually constructed, which is demonstrated on the TS Playground version of the code.</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/typescript/" rel="tag">typescript</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/programming/" rel="tag">programming</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/tuples/" rel="tag">tuples</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/type-system/" rel="tag">type system</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="Michael Poteat avatar" src="/img/avatar.png" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name"></span>
	</div>
	<div class="authorbox__description">
		Software engineer and researcher in SF. Interests in machine learning, programming, pure mathematics and many other topics.
	</div>
</div>



			</div>
			<aside class="sidebar"><div class="widget-search widget">
	<form class="widget-search__form" role="search" method="get" action="https://google.com/search">
		<label>
			<input class="widget-search__field" type="search" placeholder="SEARCH…" value="" name="q" aria-label="SEARCH…">
		</label>
		<input class="widget-search__submit" type="submit" value="Search">
		<input type="hidden" name="sitesearch" value="" />
	</form>
</div>
<div class="widget-recent widget">
	<h4 class="widget__title">Recent Posts</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item"><a class="widget__link" href="/post/programming/programs-of-length-n/">Programs of Length N: Collatz, Chaitin, and Church</a></li>
			<li class="widget__item"><a class="widget__link" href="/post/programming/unchained-tuple-types/">Unchained Tuple Types</a></li>
			<li class="widget__item"><a class="widget__link" href="/post/programming/type-level-dedupe/">String Deduplication on the Type Level</a></li>
			<li class="widget__item"><a class="widget__link" href="/post/programming/chained-tuple-types/">Chained Tuple Types</a></li>
			<li class="widget__item"><a class="widget__link" href="/post/programming/enforcing-function-map-constraints/">Enforcing Function Map Constraints</a></li>
		</ul>
	</div>
</div>
<div class="widget-categories widget">
	<h4 class="widget__title">Categories</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item">
				<a class="widget__link" href="/categories/algorithms/">algorithms</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/bioinformatics/">bioinformatics</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/life/">life</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/mathematics/">mathematics</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/programming/">programming</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/simulation/">simulation</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/typescript/">typescript</a>
			</li>
		</ul>
	</div>
</div>
<div class="widget-taglist widget">
	<h4 class="widget__title">Tags</h4>
	<div class="widget__content">
		<a class="widget-taglist__link widget__link btn" href="/tags/algorithms/" title="algorithms">algorithms</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/curves/" title="curves">curves</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/demo/" title="demo">demo</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/design-patterns/" title="design patterns">design patterns</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/dijkstra/" title="dijkstra">dijkstra</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/factorization/" title="factorization">factorization</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/javascript/" title="javascript">javascript</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/lambda-calculus/" title="lambda calculus">lambda calculus</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/latex/" title="latex">latex</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/math/" title="math">math</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/mathematica/" title="mathematica">mathematica</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/number-theory/" title="number theory">number theory</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/parsing/" title="parsing">parsing</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/physics/" title="physics">physics</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/programming/" title="programming">programming</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/rationality/" title="rationality">rationality</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/regression/" title="regression">regression</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/strings/" title="strings">strings</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/tau-beta-pi/" title="tau-beta-pi">tau-beta-pi</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/tuples/" title="tuples">tuples</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/type-system/" title="type system">type system</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/typescript/" title="typescript">typescript</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/wip/" title="wip">wip</a>
	</div>
</div>
</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2021 Code, lol..
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>